{"version":3,"file":"react-model-store.umd.js","sources":["../src/react-model-store.ts"],"sourcesContent":["/**\n * @license ReactModelStore v0.4.0-beta2\n * (c) 2019 bucatini\n * License: MIT\n */\n\nimport React from 'react';\n\nexport type Accessor<T extends any> = (() => T) & ((value: T) => void);\nexport type Action<TArgs extends any[] = []> = (...args: TArgs) => void;\nexport type Event<TArgs extends any[]> = Action<TArgs> & {\n  add(listener: Action<TArgs>, dep?: ModelBase): boolean;\n  remove(listener: Action<TArgs>): boolean;\n  clear(): void;\n};\nexport type ModelClass<TModel extends {}, TValue> = TValue extends void\n  ? {\n      new (): TModel;\n    }\n  : {\n      new (initialValue: TValue): TModel;\n    };\n\ntype InitialValue<TValue> = TValue extends void\n  ? {}\n  : unknown extends TValue\n  ? { initialValue?: TValue }\n  : { initialValue: TValue };\n\nexport type StoreProviderProps<TValue = void> = InitialValue<TValue> & {\n  children?: React.ReactNode;\n};\n\nexport interface StoreConsumerProps<TModel extends {}> {\n  children: (model: TModel) => React.ReactNode;\n}\n\nexport interface Consumable<TModel extends {}> {\n  consume(): TModel;\n}\n\nexport type StoreProvider<TValue = void> = React.FunctionComponent<\n  StoreProviderProps<TValue>\n>;\nexport type StoreConsumer<TModel extends {}> = React.FunctionComponent<\n  StoreConsumerProps<TModel>\n> &\n  Consumable<TModel>;\n\nexport interface Store<TModel extends {}, TValue = void>\n  extends Consumable<TModel> {\n  readonly Provider: StoreProvider<TValue>;\n  readonly Consumer: StoreConsumer<TModel>;\n}\n\ninterface Box<T> {\n  inner: T;\n}\n\nclass Meta {\n  readonly models: ModelBase[] = [];\n  finalized: boolean = false;\n  mounted: boolean = true;\n  readonly hooks: Action[] = [];\n  readonly mountEvents: Action[] = [];\n  readonly unmountEvents: Action[] = [];\n\n  deceiveHooks(): void {\n    this.hooks.forEach(useHook => {\n      useHook();\n    });\n  }\n}\n\nconst metaStore = new Map<{}, Meta>();\nconst current = {\n  meta: null as Meta | null,\n};\nconst listenerDependencyStore = new Map<\n  ModelBase,\n  Map<Action<any>, Event<any>>\n>();\n\nfunction isConsumable(source: any): boolean {\n  return typeof source['consume'] === 'function';\n}\n\nfunction createEvent<TArgs extends any[]>(): Event<TArgs> {\n  const listenerMap = new Map<Action<TArgs>, ModelBase | null>();\n\n  function event(...args: TArgs): void {\n    listenerMap.forEach((_, listener) => {\n      listener(...args);\n    });\n  }\n\n  function add(listener: Action<TArgs>, dep?: ModelBase): boolean {\n    if (dep && !(dep as any).mounted) {\n      throw new Error('Cannot add event listener to unmounted model objects');\n    }\n    if (listenerMap.has(listener)) {\n      return false;\n    }\n    listenerMap.set(listener, dep === undefined ? null : dep);\n    if (dep) {\n      let map = listenerDependencyStore.get(dep);\n      if (map === undefined) {\n        listenerDependencyStore.set(dep, (map = new Map()));\n      }\n      map.set(listener, event as Event<TArgs>);\n    }\n    return true;\n  }\n\n  function remove(listener: Action<TArgs>): boolean {\n    const dep = listenerMap.get(listener);\n    if (dep === undefined) {\n      return false;\n    }\n    listenerMap.delete(listener);\n    if (dep) {\n      listenerDependencyStore.get(dep)!.delete(listener);\n    }\n    return true;\n  }\n\n  function clear(): void {\n    const listeners: Action<TArgs>[] = [];\n    listenerMap.forEach((_, listener) => {\n      listeners.push(listener);\n    });\n    listeners.forEach(listener => {\n      remove(listener);\n    });\n  }\n\n  Object.defineProperties(event, {\n    add: {\n      value: add,\n    },\n    remove: {\n      value: remove,\n    },\n    clear: {\n      value: clear,\n    },\n  });\n\n  return event as Event<TArgs>;\n}\n\nfunction createStateAccessor<T extends any>(\n  meta: Meta,\n  initialValue: T | (() => T),\n  finalizeRequired: boolean\n): Accessor<T> {\n  if (meta.finalized) {\n    throw new Error(\n      'createStateAccessor() must be called from constructors of classes that extend ModelBase'\n    );\n  }\n\n  let state =\n    typeof initialValue === 'function'\n      ? (initialValue as () => T)()\n      : initialValue;\n  let setState = React.useState(state)[1];\n  meta.hooks.push(() => {\n    setState = React.useState(state)[1];\n  });\n\n  const getter = () => state;\n  const setter = (value: T) => {\n    if (meta.mounted) {\n      state = value;\n      setState(state);\n    }\n  };\n\n  function accessor(value?: T): any {\n    return arguments.length === 0 ? getter() : setter(value!);\n  }\n\n  if (finalizeRequired) {\n    Object.defineProperties(accessor, {\n      _finalizeRequired: { value: true },\n      _getter: { value: getter },\n      _setter: { value: setter },\n    });\n  }\n  return accessor;\n}\n\nexport abstract class ModelBase {\n  private readonly _meta: Meta;\n\n  constructor() {\n    if (!current.meta) {\n      throw new Error(\n        'ModelBase constructor must be called from Provider of Store created by createStore() or Component created by createComponent().'\n      );\n    }\n    this._meta = current.meta;\n    this._meta.mountEvents.push(() => {\n      this.onMount();\n    });\n    this._meta.unmountEvents.push(() => {\n      this.onUnmount();\n      const removeListenerMap = listenerDependencyStore.get(this);\n      if (removeListenerMap !== undefined) {\n        const targets: [Event<any>, Action<any>][] = [];\n        removeListenerMap.forEach((eventHandler, listener) =>\n          targets.push([eventHandler, listener])\n        );\n        targets.forEach(([eventHandler, listener]) => {\n          eventHandler.remove(listener);\n        });\n        listenerDependencyStore.delete(this);\n      }\n    });\n  }\n\n  protected get mounted(): boolean {\n    return this._meta.mounted;\n  }\n\n  // tslint:disable-next-line: no-empty\n  protected onMount(): void {}\n\n  // tslint:disable-next-line: no-empty\n  protected onUnmount(): void {}\n\n  protected hook<T = void>(useHook: () => T): T {\n    if (this._meta.finalized) {\n      throw new Error(\n        'hook() must be called from the constructor of classes that extend ModelBase'\n      );\n    }\n    const result = useHook();\n    this._meta.hooks.push(useHook);\n    return result;\n  }\n\n  protected model<TModel extends {}, TValue>(\n    modelClass: ModelClass<TModel, TValue>,\n    initialValue: TValue\n  ): TModel;\n\n  protected model<TModel extends {}>(\n    consubable: Store<TModel, any> | StoreConsumer<TModel> | Consumable<TModel>\n  ): TModel;\n\n  protected model<TModel extends {}>(\n    source: ModelClass<TModel, any> | Consumable<TModel>,\n    initialValue?: any\n  ): TModel {\n    if (isConsumable(source)) {\n      const consumable = source as Consumable<TModel>;\n      return this.hook(() => consumable.consume());\n    } else {\n      return arguments.length > 1\n        ? new (source as ModelClass<TModel, any>)(initialValue)\n        : new (source as ModelClass<TModel, void>)();\n    }\n  }\n\n  protected ref<T>(initialValue?: T): React.RefObject<T> {\n    return arguments.length === 0\n      ? React.createRef()\n      : ({ current: initialValue } as React.RefObject<T>);\n  }\n\n  protected event(): Event<[]>;\n\n  protected event<TArgs extends any[]>(listener?: Action<TArgs>): Event<TArgs>;\n\n  protected event<T>(listener?: Action<[T]>): Event<[T]>;\n  protected event<T1, T2>(listener?: Action<[T1, T2]>): Event<[T1, T2]>;\n  protected event<T1, T2, T3>(\n    listener?: Action<[T1, T2, T3]>\n  ): Event<[T1, T2, T3]>;\n  protected event<T1, T2, T3, T4>(\n    listener?: Action<[T1, T2, T3, T4]>\n  ): Event<[T1, T2, T3, T4]>;\n  protected event<T1, T2, T3, T4, T5>(\n    listener?: Action<[T1, T2, T3, T4, T5]>\n  ): Event<[T1, T2, T3, T4, T5]>;\n  protected event<T1, T2, T3, T4, T5, T6>(\n    listener?: Action<[T1, T2, T3, T4, T5, T6]>\n  ): Event<[T1, T2, T3, T4, T5, T6]>;\n  protected event<T1, T2, T3, T4, T5, T6, T7>(\n    listener?: Action<[T1, T2, T3, T4, T5, T6, T7]>\n  ): Event<[T1, T2, T3, T4, T5, T6, T7]>;\n  protected event<T1, T2, T3, T4, T5, T6, T7, T8>(\n    listener?: Action<[T1, T2, T3, T4, T5, T6, T7, T8]>\n  ): Event<[T1, T2, T3, T4, T5, T6, T7, T8]>;\n\n  protected event(listener?: Action<any[]>): Event<any[]> {\n    const e = createEvent<any[]>();\n    if (listener) {\n      e.add(listener, this);\n    }\n    return e;\n  }\n\n  protected addListener<TArgs extends any[]>(\n    event: Event<TArgs>,\n    listener: Action<TArgs>\n  ): boolean {\n    return event.add(listener, this);\n  }\n\n  protected removeListener<TArgs extends any[]>(\n    event: Event<TArgs>,\n    listener: Action<TArgs>\n  ): boolean {\n    return event.remove(listener);\n  }\n}\n\n/**\n * PureModel can only use functional state accessors.\n * In case model objects are created frequently,\n * PureModel objects are created at a lower cost than Model objects.\n */\nexport abstract class PureModel extends ModelBase {\n  /**\n   * @example\n   * class CounterModel extends PureModel {\n   *   // state() is used to define functional state getter/setter.\n   *   private readonly _count= this.state<number>(0);\n   *\n   *   get count(): number {\n   *     return this._count();\n   *   }\n   *\n   *   readonly increment = () => this._count(this.count + 1);\n   * }\n   *\n   * @param initialValue an initial value or a function that returns it.\n   */\n  protected state<T extends any>(initialValue: T | (() => T)): Accessor<T> {\n    return createStateAccessor(\n      (this as any)._meta as Meta,\n      initialValue,\n      false\n    );\n  }\n}\n\n/**\n * Model-based React Hooks wrapper.\n * In case of using React Hooks from constructor of derived classes,\n * React Hooks functions must be called through the use of useHook() function.\n *\n * @example\n * class ComponentModel extends Model {\n *   // this.state() method is React.useState() wrapper.\n *   message: string = this.state('initial state value');\n *\n *   update(newMessage: string): void {\n *     this.message = newMessage; // call setState()\n *   }\n * }\n */\nexport abstract class Model extends ModelBase {\n  constructor() {\n    super();\n    ((this as any)._meta as Meta).models.push(this);\n  }\n\n  /**\n   * This function must be called from constructor, and properties defined by this function must not be accessed from constructor.\n   *\n   * @example\n   * class CounterModel extends Model {\n   *   // State values can be accessed as variable after Model constructor is called.\n   *   count: number = this.state(0);\n   *\n   *   readonly increment = () => this.count = this.count + 1;\n   * }\n   *\n   * @param initialValue an initial value or a function that returns it.\n   */\n  protected state<T extends any>(initialValue: T | (() => T)): T {\n    return (createStateAccessor(\n      (this as any)._meta as Meta,\n      initialValue,\n      true\n    ) as unknown) as T;\n  }\n\n  /**\n   * @example\n   * class CounterModel extends Model {\n   *   // stateFunc() is used to define functional state getter/setter.\n   *   private readonly _count = this.stateFunc<number>(0);\n   *\n   *   get count(): number {\n   *     return this._count();\n   *   }\n   *\n   *   readonly increment = () => this._count(this.count + 1);\n   * }\n   *\n   * @param initialValue an initial value or a function that returns it.\n   */\n  protected stateFunc<T extends any>(initialValue: T | (() => T)): Accessor<T> {\n    return createStateAccessor(\n      (this as any)._meta as Meta,\n      initialValue,\n      false\n    );\n  }\n}\n\nfunction finalize(meta: Meta): void {\n  for (const model of meta.models) {\n    Object.entries(model).forEach(([k, v]) => {\n      if (typeof v === 'function' && v._finalizeRequired === true) {\n        Object.defineProperty(model, k, {\n          get: v._getter,\n          set: v._setter,\n        });\n      }\n    });\n  }\n}\n\nfunction resolveModel<TModel extends {}>(createModel: () => TModel): TModel {\n  const ref = React.useRef<TModel>();\n  let meta: Meta;\n  if (!ref.current) {\n    let model: TModel;\n    current.meta = meta = new Meta();\n    try {\n      model = createModel();\n    } finally {\n      current.meta = null;\n    }\n    metaStore.set(model, meta);\n    finalize(meta);\n    meta.finalized = true;\n    ref.current = model;\n  } else {\n    meta = metaStore.get(ref.current)!;\n    meta.deceiveHooks();\n  }\n\n  React.useEffect(() => {\n    meta.mountEvents.forEach(onMount => onMount());\n    return () => {\n      for (let i = meta.unmountEvents.length - 1; i >= 0; i--) {\n        meta.unmountEvents[i]();\n      }\n      meta.mounted = false;\n      metaStore.delete(ref.current!);\n    };\n  }, []);\n\n  return ref.current!;\n}\n\n/**\n * Create a model store that wrapped Context API.\n * It is useful when nested components need to reference the model.\n * Every time <Store.Provider> is mounted, Store creates a model object.\n * <Store.Provider> provides the model object to nested components.\n * Then <Store.Consumer> or useModel(Store) can consume the model object.\n * @param modelClass\n * @returns Store object\n */\nexport function createStore<TModel extends {}, TValue>(\n  modelClass: ModelClass<TModel, TValue>\n): Store<TModel, TValue> {\n  const Context = React.createContext<Box<TModel> | null>(null);\n\n  const Provider = (props: StoreProviderProps<TValue>) => {\n    const createModel =\n      'initialValue' in props\n        ? () => new modelClass((props as { initialValue: TValue }).initialValue)\n        : () => new (modelClass as ModelClass<TModel, void>)();\n    const model = resolveModel(createModel);\n    return React.createElement(\n      Context.Provider,\n      { value: { inner: model } },\n      props.children\n    );\n  };\n\n  const Consumer = (props: StoreConsumerProps<TModel>) => {\n    const consumerProps = {\n      children(box: Box<TModel> | null): React.ReactNode {\n        if (box === null) {\n          throw new Error(\n            '<Store.Consumer> must be wrapped with <Store.Provider>'\n          );\n        }\n        return props.children(box.inner);\n      },\n    };\n    return React.createElement(Context.Consumer, consumerProps);\n  };\n\n  const consume = () => {\n    const box = React.useContext(Context);\n    if (box === null) {\n      throw new Error(\n        'Consumable.consume() must be wrapped with <Store.Provider>'\n      );\n    }\n    return box.inner;\n  };\n\n  Object.defineProperties(Consumer, {\n    consume: { value: consume },\n  });\n\n  const store = {};\n\n  Object.defineProperties(store, {\n    Provider: { value: Provider },\n    Consumer: { value: Consumer },\n    consume: { value: consume },\n  });\n\n  return store as Store<TModel, TValue>;\n}\n\n/**\n * useModel returns a model object provided by Store.Provider element in functional component.\n * @param consumable is an object that implements Consumable interface.\n * @returns model object\n */\nexport function useModel<TModel extends {}>(\n  consumable: Store<TModel, any> | StoreConsumer<TModel> | Consumable<TModel>\n): TModel;\n\n/**\n * useModel returns a model object related to functional component.\n * @param modelClass is model class constructor\n * @param initialValue is passed to the model class constructor.\n * @returns model object\n */\nexport function useModel<TModel extends {}, TValue>(\n  modelClass: ModelClass<TModel, TValue>,\n  initialValue: TValue\n): TModel;\n\nexport function useModel<TModel extends {}>(\n  source: ModelClass<TModel, any> | Consumable<TModel>,\n  initialValue?: any\n): TModel {\n  if (isConsumable(source)) {\n    const consumable = source as Consumable<TModel>;\n    return consumable.consume();\n  } else {\n    const createModel =\n      arguments.length > 1\n        ? () => new (source as ModelClass<TModel, any>)(initialValue)\n        : () => new (source as ModelClass<TModel, void>)();\n    return resolveModel(createModel);\n  }\n}\n"],"names":["Meta","constructor","deceiveHooks","hooks","forEach","useHook","const","metaStore","Map","current","meta","listenerDependencyStore","isConsumable","source","createEvent","listenerMap","event","_","listener","args","add","dep","mounted","Error","has","set","undefined","map","get","remove","delete","clear","listeners","push","Object","defineProperties","value","createStateAccessor","initialValue","finalizeRequired","finalized","state","setState","React","useState","getter","setter","accessor","arguments","length","_finalizeRequired","_getter","_setter","ModelBase","_meta","mountEvents","onMount","unmountEvents","onUnmount","removeListenerMap","this","targets","eventHandler","hook","result","model","consumable","consume","ref","createRef","e","addListener","removeListener","PureModel","Model","models","stateFunc","finalize","entries","v","defineProperty","k","resolveModel","createModel","useRef","useEffect","let","i","createStore","modelClass","Context","createContext","Provider","props","createElement","inner","children","Consumer","consumerProps","box","useContext","store","useModel"],"mappings":";;;;;;;;EAAA;;;;;AAMA;EAqDA,IAAMA,IAAN,GAAAC;eACW,GAAsB,EAAtB;kBACT,GAAqB,KAArB;gBACA,GAAmB,IAAnB;cACS,GAAkB,EAAlB;oBACA,GAAwB,EAAxB;sBACA,GAA0B,EAA1B;;;EAETC,eAAAA;SACOC,KAAL,CAAWC,OAAX,WAAmBC;aACV;KADT;;;EAMJC,IAAMC,SAAS,GAAG,IAAIC,GAAJ,EAAlB;EACAF,IAAMG,OAAO,GAAG;IACdC,IAAI,EAAE;GADR;EAGAJ,IAAMK,uBAAuB,GAAG,IAAIH,GAAJ,EAAhC;;EAKA,SAASI,YAAT,CAAsBC,MAAtB;WACS,OAAOA,MAAM,CAAC,SAAD,CAAb,KAA6B,UAApC;;;EAGF,SAASC,WAAT;QACQC,WAAW,GAAG,IAAIP,GAAJ,EAApB;;aAESQ,KAAT;;;;MACED,WAAW,CAACX,OAAZ,WAAqBa,CAAD,EAAIC,QAAJ;QAClBA,cAAQ,CAAC,QAAGC,IAAJ,CAAR;OADF;;;aAKOC,GAAT,CAAaF,QAAb,EAAsCG,GAAtC;UACMA,GAAG,IAAI,CAAEA,GAAW,CAACC,OAAzB,EAAkC;cAC1B,IAAIC,KAAJ,CAAU,sDAAV,CAAN;;;UAEER,WAAW,CAACS,GAAZ,CAAgBN,QAAhB,CAAJ,EAA+B;eACtB,KAAP;;;MAEFH,WAAW,CAACU,GAAZ,CAAgBP,QAAhB,EAA0BG,GAAG,KAAKK,SAAR,GAAoB,IAApB,GAA2BL,GAArD;;UACIA,GAAJ,EAAS;YACHM,GAAG,GAAGhB,uBAAuB,CAACiB,GAAxB,CAA4BP,GAA5B,CAAV;;YACIM,GAAG,KAAKD,SAAZ,EAAuB;UACrBf,uBAAuB,CAACc,GAAxB,CAA4BJ,GAA5B,EAAkCM,GAAG,GAAG,IAAInB,GAAJ,EAAxC;;;QAEFmB,GAAG,CAACF,GAAJ,CAAQP,QAAR,EAAkBF,KAAlB;;;aAEK,IAAP;;;aAGOa,MAAT,CAAgBX,QAAhB;UACQG,GAAG,GAAGN,WAAW,CAACa,GAAZ,CAAgBV,QAAhB,CAAZ;;UACIG,GAAG,KAAKK,SAAZ,EAAuB;eACd,KAAP;;;MAEFX,WAAW,CAACe,MAAZ,CAAmBZ,QAAnB;;UACIG,GAAJ,EAAS;QACPV,uBAAuB,CAACiB,GAAxB,CAA4BP,GAA5B,EAAkCS,MAAlC,CAAyCZ,QAAzC;;;aAEK,IAAP;;;aAGOa,KAAT;UACQC,SAAS,GAAoB,EAAnC;MACAjB,WAAW,CAACX,OAAZ,WAAqBa,CAAD,EAAIC,QAAJ;QAClBc,SAAS,CAACC,IAAV,CAAef,QAAf;OADF;MAGAc,SAAS,CAAC5B,OAAV,WAAkBc;QAChBW,MAAM,CAACX,QAAD,CAAN;OADF;;;IAKFgB,MAAM,CAACC,gBAAP,CAAwBnB,KAAxB,EAA+B;MAC7BI,GAAG,EAAE;QACHgB,KAAK,EAAEhB;OAFoB;MAI7BS,MAAM,EAAE;QACNO,KAAK,EAAEP;OALoB;MAO7BE,KAAK,EAAE;QACLK,KAAK,EAAEL;;KARX;WAYOf,KAAP;;;EAGF,SAASqB,mBAAT,CACE3B,IADF,EAEE4B,YAFF,EAGEC,gBAHF;QAKM7B,IAAI,CAAC8B,SAAT,EAAoB;YACZ,IAAIjB,KAAJ,CACJ,yFADI,CAAN;;;QAKEkB,KAAK,GACP,OAAOH,YAAP,KAAwB,UAAxB,GACKA,YAAwB,EAD7B,GAEIA,YAHN;QAIII,QAAQ,GAAGC,KAAK,CAACC,QAAN,CAAeH,KAAf,EAAsB,CAAtB,CAAf;IACA/B,IAAI,CAACP,KAAL,CAAW8B,IAAX;MACES,QAAQ,GAAGC,KAAK,CAACC,QAAN,CAAeH,KAAf,EAAsB,CAAtB,CAAX;KADF;;QAIMI,MAAM,wBAASJ,QAArB;;QACMK,MAAM,aAAIV;UACV1B,IAAI,CAACY,OAAT,EAAkB;QAChBmB,KAAK,GAAGL,KAAR;QACAM,QAAQ,CAACD,KAAD,CAAR;;KAHJ;;aAOSM,QAAT,CAAkBX,KAAlB;aACSY,SAAS,CAACC,MAAV,KAAqB,CAArB,GAAyBJ,MAAM,EAA/B,GAAoCC,MAAM,CAACV,KAAD,CAAjD;;;QAGEG,gBAAJ,EAAsB;MACpBL,MAAM,CAACC,gBAAP,CAAwBY,QAAxB,EAAkC;QAChCG,iBAAiB,EAAE;UAAEd,KAAK,EAAE;SADI;QAEhCe,OAAO,EAAE;UAAEf,KAAK,EAAES;SAFc;QAGhCO,OAAO,EAAE;UAAEhB,KAAK,EAAEU;;OAHpB;;;WAMKC,QAAP;;;AAGF,MAAsBM,YAGpBpD;;;QACM,CAACQ,OAAO,CAACC,IAAb,EAAmB;YACX,IAAIa,KAAJ,CACJ,iIADI,CAAN;;;SAIG+B,KAAL,GAAa7C,OAAO,CAACC,IAArB;;SACK4C,KAAL,CAAWC,WAAX,CAAuBtB,IAAvB;aACOuB,OAAL;KADF;;SAGKF,KAAL,CAAWG,aAAX,CAAyBxB,IAAzB;aACOyB,SAAL;UACMC,iBAAiB,GAAGhD,uBAAuB,CAACiB,GAAxB,CAA4BgC,MAA5B,CAA1B;;UACID,iBAAiB,KAAKjC,SAA1B,EAAqC;YAC7BmC,OAAO,GAAgC,EAA7C;yBACiB,CAACzD,OAAlB,WAA2B0D,YAAD,EAAe5C,QAAf,WACxB2C,OAAO,CAAC5B,IAAR,CAAa,CAAC6B,YAAD,EAAe5C,QAAf,CAAb,IADF;eAGO,CAACd,OAAR,WAAiB,GAAD;oCAAgBc;;;UAC9B4C,YAAY,CAACjC,MAAb,CAAoBX,QAApB;SADF;QAGAP,uBAAuB,CAACmB,MAAxB,CAA+B8B,MAA/B;;KAXJ;EAcD;;;;EAED,mBAActC;WACL,KAAKgC,KAAL,CAAWhC,OAAlB;;;;EAIQkC,oBAAAA;;;EAGAE,oBAAAA;;EAEAK,oBAAAA,sBAAe1D,OAAX;QACR,KAAKiD,KAAL,CAAWd,SAAf,EAA0B;YAClB,IAAIjB,KAAJ,CACJ,6EADI,CAAN;;;QAIIyC,MAAM,GAAG3D,OAAO,EAAtB;;SACKiD,KAAL,CAAWnD,KAAX,CAAiB8B,IAAjB,CAAsB5B,OAAtB;;WACO2D,MAAP;;;EAYQC,oBAAAA,wBACRpD,MADa,EAEbyB,YAFa;QAIT1B,YAAY,CAACC,MAAD,CAAhB,EAA0B;UAClBqD,UAAU,GAAGrD,MAAnB;aACO,KAAKkD,IAAL,sBAAgBG,UAAU,CAACC,OAAX,KAAhB,CAAP;KAFF,MAGO;aACEnB,SAAS,CAACC,MAAV,GAAmB,CAAnB,GACH,IAAKpC,MAAL,CAAwCyB,YAAxC,CADG,GAEH,IAAKzB,MAAL,EAFJ;;;;EAMMuD,oBAAAA,oBAAO9B,YAAJ;WACJU,SAAS,CAACC,MAAV,KAAqB,CAArB,GACHN,KAAK,CAAC0B,SAAN,EADG,GAEF;aAAS,EAAE/B;KAFhB;;;EA8BQtB,oBAAAA,wBAAME,QAAD;QACPoD,CAAC,GAAGxD,WAAW,EAArB;;QACII,QAAJ,EAAc;OACX,CAACE,GAAF,CAAMF,QAAN,EAAgB,IAAhB;;;WAEKoD,CAAP;;;EAGQC,oBAAAA,oCACRvD,KADmB,EAEnBE,QAFmB;WAIZF,KAAK,CAACI,GAAN,CAAUF,QAAV,EAAoB,IAApB,CAAP;;;EAGQsD,oBAAAA,0CACRxD,KADsB,EAEtBE,QAFsB;WAIfF,KAAK,CAACa,MAAN,CAAaX,QAAb,CAAP;;;;;;;;;;AASJ,MAAsBuD;;;;;;;;;wBAgBVhC,wBAAqBH,YAAhB;aACND,mBAAmB,CACvB,KAAaiB,KADU,EAExBhB,YAFwB,EAGxB,KAHwB,CAA1B;;;;IAjBoCe;;;;;;;;;;;;;;;;;AAwCxC,MAAsBqB;IACpBzE;;;WAEiBqD,KAAb,CAA4BqB,MAA5B,CAAmC1C,IAAnC,CAAwC,IAAxC;;;;;;;;;;;;;;;;;;;;;oBAgBMQ,wBAAqBH,YAAhB;aACLD,mBAAmB,CACxB,KAAaiB,KADW,EAEzBhB,YAFyB,EAGzB,IAHyB,CAA3B;;;;;;;;;;;;;;;;;;;oBAsBQsC,gCAAyBtC,YAAhB;aACVD,mBAAmB,CACvB,KAAaiB,KADU,EAExBhB,YAFwB,EAGxB,KAHwB,CAA1B;;;;IA3CgCe;;EAmDpC,SAASwB,QAAT,CAAkBnE,IAAlB;2BACmC;MAA5BJ,IAAM2D;;MACT/B,MAAM,CAAC4C,OAAP,CAAeb,KAAf,EAAsB7D,OAAtB,WAA+B,GAAD;uBAAK2E;;;YAC7B,OAAOA,CAAP,KAAa,UAAb,IAA2BA,CAAC,CAAC7B,iBAAF,KAAwB,IAAvD,EAA6D;UAC3DhB,MAAM,CAAC8C,cAAP,CAAsBf,KAAtB,EAA6BgB,CAA7B,EAAgC;YAC9BrD,GAAG,EAAEmD,CAAC,CAAC5B,OADuB;YAE9B1B,GAAG,EAAEsD,CAAC,CAAC3B;WAFT;;OAFJ;;;SADG,kBAAe1C,IAAI,CAACiE,+BAAzB;;;EAYF,SAASO,YAAT,CAAyCC,WAAzC;QACQf,GAAG,GAAGzB,KAAK,CAACyC,MAAN,EAAZ;QACI1E,IAAJ;;QACI,CAAC0D,GAAG,CAAC3D,OAAT,EAAkB;UACZwD,KAAJ;MACAxD,OAAO,CAACC,IAAR,GAAeA,IAAI,GAAG,IAAIV,IAAJ,EAAtB;;UACI;QACFiE,KAAK,GAAGkB,WAAW,EAAnB;OADF,SAEU;QACR1E,OAAO,CAACC,IAAR,GAAe,IAAf;;;MAEFH,SAAS,CAACkB,GAAV,CAAcwC,KAAd,EAAqBvD,IAArB;MACAmE,QAAQ,CAACnE,IAAD,CAAR;MACAA,IAAI,CAAC8B,SAAL,GAAiB,IAAjB;MACA4B,GAAG,CAAC3D,OAAJ,GAAcwD,KAAd;KAXF,MAYO;MACLvD,IAAI,GAAGH,SAAS,CAACqB,GAAV,CAAcwC,GAAG,CAAC3D,OAAlB,CAAP;MACAC,IAAI,CAACR,YAAL;;;IAGFyC,KAAK,CAAC0C,SAAN;MACE3E,IAAI,CAAC6C,WAAL,CAAiBnD,OAAjB,WAAyBoD,kBAAWA,OAAO,KAA3C;;aAEO8B,IAAIC,CAAC,GAAG7E,IAAI,CAAC+C,aAAL,CAAmBR,MAAnB,GAA4B,CAAzC,EAA4CsC,CAAC,IAAI,CAAjD,EAAoDA,CAAC,EAArD,EAAyD;UACvD7E,IAAI,CAAC+C,aAAL,CAAmB8B,CAAnB;;;QAEF7E,IAAI,CAACY,OAAL,GAAe,KAAf;QACAf,SAAS,CAACuB,MAAV,CAAiBsC,GAAG,CAAC3D,OAArB;OALF;KAFF,EASG,EATH;WAWO2D,GAAG,CAAC3D,OAAX;;;;;;;;;;;;;AAYF,WAAgB+E,YACdC;QAEMC,OAAO,GAAG/C,KAAK,CAACgD,aAAN,CAAwC,IAAxC,CAAhB;;QAEMC,QAAQ,aAAIC;UACVV,WAAW,GACf,kBAAkBU,KAAlB,wBACU,IAAIJ,UAAJ,CAAgBI,KAAkC,CAACvD,YAAnD,IADV,wBAEU,IAAKmD,UAAL,KAHZ;UAIMxB,KAAK,GAAGiB,YAAY,CAACC,WAAD,CAA1B;aACOxC,KAAK,CAACmD,aAAN,CACLJ,OAAO,CAACE,QADH,EAEL;QAAExD,KAAK,EAAE;UAAE2D,KAAK,EAAE9B;;OAFb,EAGL4B,KAAK,CAACG,QAHD,CAAP;KANF;;QAaMC,QAAQ,aAAIJ;UACVK,aAAa,GAAG;QACpBF,2BAAQ,CAACG,GAAD;cACFA,GAAG,KAAK,IAAZ,EAAkB;kBACV,IAAI5E,KAAJ,CACJ,wDADI,CAAN;;;iBAIKsE,KAAK,CAACG,QAAN,CAAeG,GAAG,CAACJ,KAAnB,CAAP;;;OAPJ;aAUOpD,KAAK,CAACmD,aAAN,CAAoBJ,OAAO,CAACO,QAA5B,EAAsCC,aAAtC,CAAP;KAXF;;QAcM/B,OAAO;UACLgC,GAAG,GAAGxD,KAAK,CAACyD,UAAN,CAAiBV,OAAjB,CAAZ;;UACIS,GAAG,KAAK,IAAZ,EAAkB;cACV,IAAI5E,KAAJ,CACJ,4DADI,CAAN;;;aAIK4E,GAAG,CAACJ,KAAX;KAPF;;IAUA7D,MAAM,CAACC,gBAAP,CAAwB8D,QAAxB,EAAkC;MAChC9B,OAAO,EAAE;QAAE/B,KAAK,EAAE+B;;KADpB;QAIMkC,KAAK,GAAG,EAAd;IAEAnE,MAAM,CAACC,gBAAP,CAAwBkE,KAAxB,EAA+B;MAC7BT,QAAQ,EAAE;QAAExD,KAAK,EAAEwD;OADU;MAE7BK,QAAQ,EAAE;QAAE7D,KAAK,EAAE6D;OAFU;MAG7B9B,OAAO,EAAE;QAAE/B,KAAK,EAAE+B;;KAHpB;WAMOkC,KAAP;;AAuBF,WAAgBC,SACdzF,QACAyB;QAEI1B,YAAY,CAACC,MAAD,CAAhB,EAA0B;UAClBqD,UAAU,GAAGrD,MAAnB;aACOqD,UAAU,CAACC,OAAX,EAAP;KAFF,MAGO;UACCgB,WAAW,GACfnC,SAAS,CAACC,MAAV,GAAmB,CAAnB,wBACU,IAAKpC,MAAL,CAAwCyB,YAAxC,IADV,wBAEU,IAAKzB,MAAL,KAHZ;aAIOqE,YAAY,CAACC,WAAD,CAAnB;;;;;;;;;;;;;;"}